-- DDL->DATA DEFINITION LANGUAGE
-- CREATE, ALTER, DROP, MODIFY, RENAME
-- -----------------------------
CREATE TABLE PRODUCTS(
PRODID INT PRIMARY KEY AUTO_INCREMENT,
PROD_NAME VARCHAR(50),
PRICE INT,
ENT_DT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
);

-- TO ADD NEW COLUMN
ALTER TABLE PRODUCTS ADD MOD_BY VARCHAR(20);
--               OR
ALTER TABLE PRODUCTS ADD COLUMN MOD_BY VARCHAR(20);

-- TO DROP THE COLUMN
ALTER TABLE PRODUCTS DROP MOD_BY;

-- TO MODIFY THE COLUMN
ALTER TABLE PRODUCTS MODIFY PRICE INT CHECK (PRICE>0);

-- TO DROP AUTO_INCREMENT
ALTER TABLE PRODUCTS MODIFY PRODID INT;

-- TO RENAME THE TABLE NAME
ALTER TABLE PRODUCTS RENAME TO PRODUCT;
--               OR 
RENAME TABLE PRODUCTS TO PRODUCT;

-- TO DROP THE TABLE
DROP TABLE PRODUCT;

-- TO REMOVE ALL THE COLUMN VALUES IN THE TABLE
TRUNCATE PRODUCT;

-- KEYS
-- PRIMARY KEY -> TABLE CAN CONTAIN ONLY ONE PRIMARY KEY
-- ADDING PRIMARY KEY
ALTER TABLE PRODUCT ADD CONSTRAINT PRIMARY KEY (PRODID);
--                       OR
ALTER TABLE PRODUCT ADD CONSTRAINT PRIMARY KEY (PRODID,PROD_NAME);

-- DROP PRIMARY KEY ->BEFORE DROPPING THE PRIMARY KEY FISRT WE HAVE TO REMOVE AUTO_INCREMENT FROM THAT COLUMN THEN ONLY IT CAN BE DROPED
ALTER TABLE PRODUCT DROP PRIMARY KEY;

-- UNIQUE KEY -> TABLE CAN CONTAIN MULTIPLE UNIQUE KEYS
ALTER TABLE PRODUCT ADD CONSTRAINT UNIQUE KEY (PRICE);

-- TO DROP UNIQUE KEY
ALTER TABLE PRODUCT DROP CONSTRAINT PRICE;

-- FOREIGN KEY -> FOREIGN  KEY ONCE IT CREATED IT CANNOT BE DELETED
ALTER TABLE PRODUCT ADD CONSTRAINT FOREIGN KEY (PRODID) REFERENCES CUSTOMER(PRODID);

-- -----------------------------------------------------------------
-- INDEX -> IT CANNOT BE VIEWED PHYSICALLY 

-- INDEX ARE USED TO RETRIEVE DATA QUICKLY
CREATE INDEX IDX ON PRODUCT (PRODID);

-- CHECK
-- CHECK MEANS CONDITION BASED VALUE
ALTER TABLE PRODUCT MODIFY PRICE INT CHECK (PRICE>0);

-- ------------------------------------------------------------------
-- DCL ->DATA CONTROL LANGUAGE

-- TO CREATE NEW USER 
CREATE USER 'root1'@'localhost' IDENTIFIED BY 'admin123';

-- GRANTING ACCESS TO THE USER
GRANT SELECT,INSERT,UPDATE,DELETE ON SYS.PRODUCT TO 'root1'@'localhost';

-- REVOKING THE ACCESS TO THE USER
REVOKE SELECT,INSERT,UPDATE,DELETE ON SYS.PRODUCT FROM 'root1'@'localhost';

-- ------------------------------------------------------------------
-- DML ->DATA MANIPULATION LANGUAGE
-- INSERT, UPDATE, DELETE

-- TO INSERT VALUES IN THE COLUMN
INSERT INTO PRODUCT (PROD_NAME,PRICE) VALUES('NEW',30);

-- TO UPDATE VALUES IN THE COLUMN
UPDATE PRODUCT SET PROD_NAME='HELLO' WHERE ID=1;

-- TO DELETE THE VALUES IN THE COLUMN
DELETE FROM PRODUCT WHERE ID=1;

-- TO DELETE ALL VALUES WITHOUT USING TRUNCATE
DELETE FROM PRODUCT WHERE 1=1;

-- -------------------------------------------------------------------
-- TCL ->TRANSACTION CONTROL LANGUAGE

COMMIT;
ROLLBACK;
SAVEPOINT PROD_NAME;
ROLLBACK TO SAVEPOINT PROD_NAME;
RELEASE SAVEPOINT PROD_NAME;
SET TRANSACTION

-- -------------------------------------------------------------------
-- DQL - DATA QUERY LANGUAGE
-- SELECT ->WHERE,WHERE NOT, IS NULL, OR, AND, IN, BETWEEN

-- SELECT BASED ON CONDITION
SELECT * FROM PRODUCT WHERE PROD_NAME='HELLO';

-- NOT MATCH CONDITION
SELECT * FROM PRODUCT WHERE NOT PROD_NAME='NEW1';
--             OR 
SELECT * FROM PRODUCT WHERE PROD_NAME<>'HELLO';

-- MATCH ANY ONE CONDITION 
SELECT * FROM PRODUCT WHERE PROD_NAME='HELLO' OR PRICE=33;

-- MATCH BOTH CONDITION
SELECT * FROM PRODUCT WHERE PROD_NAME='HELLO' AND PRICE=30;

-- -------------------------------------------------------------------
-- JOINS
-- INNER JOIN, LEFT JOIN, RIGHT JOIN, CROSS JOIN, COMPLEX JOIN

-- INNER JOIN
SELECT * FROM PRODUCT P JOIN ORDERS O ON O.PRODID=P.PRODID;

-- LEFT JOIN
SELECT * FROM PRODUCT P LEFT JOIN ORDERS O ON O.PRODID=P.PRODID;

-- RIGHT JOIN
SELECT * FROM PRODUCT P RIGHT JOIN ORDERS O ON O.PRODID=P.PRODID;

-- CROSS JOIN
SELECT * FROM CUSTOMERS CROSS JOIN PRODUCTS;

-- COMPLEX JOIN
SELECT * FROM PRODUCT P JOIN ORDERS O ON O.PRODID=P.PRODID JOIN CUSTOMERS C ON C.CUSTID=O.CUSTID;

-- ----------------------------------------------------------------------
-- WILDCARDS
-- %, [], _

-- IT SELECT FROM WHERE PROD_NAME STARTS WITH H
SELECT * FROM PRODUCT WHERE PROD_NAME LIKE 'H%';

-- IT SELECT FROM WHERE PROD_NAME ENDS WITH O 
SELECT * FROM PRODUCT WHERE PROD_NAME LIKE '%O';

-- IT SELECT FROM WHERE PROD_NAME STARTS AND ENDS WITH H 
SELECT * FROM PRODUCT WHERE PROD_NAME LIKE '%H%';

-- IT SELECT FROM WHERE PROD_NAME STARTS IN "[A-Z]"
-- SELECT * FROM PRODUCT WHERE PROD_NAME LIKE '[A-Z]%';

-- SELECT FROM WHERE "_" MATCH THE MISSING VALUES
SELECT * FROM PRODUCT WHERE PROD_NAME LIKE 'P____1';
SELECT * FROM PRODUCT WHERE PROD_NAME LIKE '_____2';

-- ----------------------------------------------------------------------
-- AGGREGATE 
-- COUNT, SUM, AVERAGE, MIN, MAX

-- USED TO FIND NO OF COLUMNS IN THE TABLE
SELECT COUNT(PROD_NAME) FROM PRODUCT; 

-- USED TO SUM THE SPECIFIC COLUMN VALUES
SELECT SUM(PRICE) FROM PRODUCT;

-- USED TO FIND AVERAGE THE SPECIFIC COLUMN VALUES
SELECT AVG(PRICE) FROM PRODUCT;

-- USED TO FIND MINIMUM VALUES IN THE COLUMN
SELECT MIN(PRICE)FROM PRODUCT;

-- USED TO FIND MAXIMUM VALUE IN THE COLUMN
SELECT MAX(PRICE) FROM PRODUCT;

-- -----------------------------------------------------------------------
-- GROUP BY
-- RULES -> GROUP BY ONLY USED TO GROUP A DUPLICATE VALUES IN THE COLUMN

-- GROUP BY PROD_NAME
SELECT PROD_NAME FROM PRODUCT GROUP BY PROD_NAME;

-- USING GROUP BY WITH AGGREGATE FUNCTION
SELECT PROD_NAME,COUNT(PROD_NAME) FROM PRODUCT GROUP BY PROD_NAME;

-- USING GROUP BY WITH AGGREGATE AND USING HAVING FOR WHERE CONDITIONS <,>,<=,>=,!= .
SELECT PROD_NAME,COUNT(PROD_NAME) FROM PRODUCT GROUP BY NAME HAVING COUNT(PROD_NAME)<=2;

-- -----------------------------------------------------------------------
-- ORDER BY 
-- RULES -> ORDER BY USED TO ORDER THE VALUES BY EITHER ASCENDING OR DESCENDING ORDER

-- TO ORDER IN ASCENDING 
SELECT * FROM PRODUCT ORDER BY PRICE;

-- TO ORDER IN DESCENDING 
SELECT PROD_NAME,PRICE FROM PRODUCT ORDER BY PRICE DESC;

-- ------------------------------------------------------------------------
-- HAVING
-- IT USED TO ADD WHERE CONDITIONS AFTER USING GROUP BY

-- GROUP BY AND HAVING
SELECT PROD_NAME,SUM(PRICE) FROM PRODUCT GROUP BY PROD_NAME HAVING SUM(PRICE)>20;

-- GROUP BY AND HAVING AND ORDER BY
SELECT CT_ROLE,COUNT(CT_ROLE) FROM MANAGEMENT GROUP BY CT_ROLE HAVING COUNT(CT_ROLE)=3 ORDER BY COUNT(CT_ROLE) DESC;

-- ------------------------------------------------------------------------
-- LIMIT AND OFFSET

-- SELECTING THE PRICE IN DESCENDING ORDER WITH TOP 3 VALUES
SELECT * FROM TESTGRP ORDER BY PRICE DESC LIMIT 3;

-- SELECTING THE PRICE IN DESCENDING ORDER WITH 3 VALUES AND SKIPPING THE FIRST 2 VALUES
SELECT * FROM TESTGRP ORDER BY PRICE DESC LIMIT 3 OFFSET 2;

-- ------------------------------------------------------------------------
-- BACKUP TABLE AND VALUES

-- COPYING THE PREVIOUS TABLE AS BACKUP TO NEW TABLE
CREATE TABLE PROD AS SELECT * FROM PRODUCT;

-- COPYING THE DATA FROM TABLE
INSERT INTO PROD SELECT * FROM PRODUCT;

-- ------------------------------------------------------------------------
-- UNION RULES -> ONLY WORK WHEN THE BOTH TABLE HAVE THE SAME NUMBER OF COLUMNS AND SAME TYPE 
-- EG:TABLE 1(INT,VARCHAR) - TABLE 2(INT,VARCHAR)

-- UNION -> (wonâ€™t duplicate with same column from 2 diff table)
SELECT * FROM PRODUCTS UNION SELECT * FROM ORDERS

-- UNION ALL -> (accept duplicate with same column from 2 diff table)
SELECT * FROM PRODUCTS UNION ALL SELECT * FROM ORDERS

-- ------------------------------------------------------------------------
-- BETWEEN 

-- IT BEWTEEN ONLY USED TO SELECT THE NUMBERS 
SELECT * FROM PRODUCT WHERE PRICE BETWEEN 23 AND 25;

-- GROUP BY->HAVING->BETWEEN->ORDER BY
SELECT CT_ROLE,COUNT(CT_ROLE) FROM MANAGEMENT GROUP BY CT_ROLE HAVING COUNT(CT_ROLE) BETWEEN 1 AND 2 ORDER BY COUNT(CT_ROLE) DESC;

-- ------------------------------------------------------------------------
-- EXISTS ,NOT EXISTS -> MOSTLY USED WITH SUBQUERY
-- ITS LIKE JOINING THE TABLE BUT DONT SHOW THE OTHER TABLE

-- CONDITION IS TRUE
SELECT * FROM PRODUCT P WHERE EXISTS(SELECT * FROM CUSTOMERS WHERE CUSTID=P.PRODID);

-- CONDITION IS FALSE
SELECT * FROM PRODUCT T WHERE NOT EXISTS(SELECT * FROM CUSTOMERS WHERE CUSTID=T.PRODID);

-- ------------------------------------------------------------------------
-- VIEW
-- STORE THE LARGER QUERIES INTO SMALLER KEY

CREATE OR REPLACE VIEW CNT AS 
SELECT CT_ROLE,COUNT(CT_ROLE) FROM MANAGEMENT GROUP BY CT_ROLE HAVING COUNT(CT_ROLE) BETWEEN 1 AND 2 ORDER BY COUNT(CT_ROLE) DESC;

SELECT * FROM CNT;

-- ------------------------------------------------------------------------
-- CASE STATEMENT -> IF ELSE
-- CONDITION MATCH ANA KUDUTHA VALUE PRINT AGUM ILANA DEFAULT 
-- VALUE PRINT AGUM AND CREATE A NEW COLUMN FOR IT 

SELECT ID,NAME,PRICE, CASE WHEN PRICE=20 THEN 'TWENTY' ELSE 'DEFAULT' END AS RATING FROM TESTGRP;

-- ------------------------------------------------------------------------
-- DUAL ->TEMPERARY TABLE

SELECT 5+5,5*5,5-3,10/5 FROM DUAL;

-- ------------------------------------------------------------------------
-- RANK() OVER() AND DENSE_RANK()

-- RANK WITH 0VER -> RANK THE PRICE
SELECT RANK() OVER(ORDER BY PRICE DESC),PRICE FROM PRODUCT; -- 1,1,1,4,5,5,7

-- DENSE_RANK
SELECT DENSE_RANK() OVER(ORDER BY PRICE DESC),PRICE FROM PRODUCT; -- 1,1,2,2,3,3,4,4

-- ------------------------------------------------------------------------
-- INBUILT METHODS 
-- INSERT, INSTR, LPAD, RPAD, MID, SUBSTR, SUBSTRING, CONCAT, SUBSTRING_INDEX,
-- ROUND, FORMAT, CEIL, FLOOR, REPEAT, UCASE, LCASE, REPLACE, REVERSE, RANK, DENSE_RANK

-- INSERT -> INSERT THE WORD WITH PREVIOUS WORD
SELECT INSERT("GOKUL KRISHNAN",1,5,"HELLO") FROM DUAL;		-- HELLO KRISHNAN

-- INSTR -> FIND THE INDEX OF THE CHARACTER
SELECT INSTR("SQL","L") FROM DUAL;		-- 3

-- LPAD -> ADD WORD TO THE LEFT
SELECT LPAD("NEW",4,"HELLO") FROM DUAL;		-- HNEW

-- RPAD -> ADD WORD TO THE RIGHT
SELECT RPAD("NEW",4,"HELLO") FROM DUAL;		-- NEWH

-- CHAR_LENGTH -> LENGTH OF THE CHARACTER
SELECT CHAR_LENGTH("WELCOME") FROM DUAL;		-- 7
SELECT CHARACTER_LENGTH("WELCOME TO SQL") FROM DUAL;	-- 14

-- MID, SUBDTR, SUBSTRING -> 
SELECT MID("WELCOME TO SQL",4,4) FROM DUAL;		-- COME
SELECT SUBSTR("WELCOME TO SQL",4,7) FROM DUAL;		-- COME TO
SELECT SUBSTRING("WELCOME TO SQL",4,12) FROM DUAL;	-- COME TO SQ

-- SPACE -> ADD SPACE
SELECT CHARACTER_LENGTH(SPACE(5)) FROM DUAL;		-- 5

-- CONCAT -> ADD STRING VALUES
SELECT CONCAT("HELLO"," WORLD"," ONE") FROM DUAL;	-- HELLO WORLD ONE

-- SUBSTRING_INDEX -> SEPARATE THE WORD WITH INDEX
SELECT SUBSTRING_INDEX("WELCOME TO SQL","O",1) FROM DUAL;	-- WELC
SELECT SUBSTRING_INDEX("WELCOME TO SQL","O",2) FROM DUAL;	-- WELCOME T
SELECT SUBSTRING_INDEX("WELCOME TO SQL","O",3) FROM DUAL;	-- WELCOME TO SQL

-- ROUND -> ROUND OF THE NUMBER
SELECT ROUND(12.34) FROM DUAL;		-- 12

-- FORMAT -> ROUND OF THE DECIMEL VALUE
SELECT FORMAT(12.345,2) FROM DUAL;	-- 12.35

-- CEIL -> ROUND THE NUMBER INTO HIGHER VALUE
SELECT CEIL(12.04) FROM DUAL;		-- 13

-- FLOOR -> ROUND THE NUMBER INTO LOWER VALUE
SELECT FLOOR(12.90) FROM DUAL;		-- 12

-- TO_DATE WORKS IN ORACLE
-- SELECT TO_DATE("2002-01-15","YYYY-MM-DD") FROM DUAL;

-- REPEAT -> REPEAT THE WORD
SELECT REPEAT("SQL ",3) FROM DUAL; 	-- SQL SQL SQL

-- REPLACE
SELECT REPLACE("HELLO WORLD","HELLO","NEW") FROM DUAL;

-- UCASE AND LCASE -> UPPER CASE AND LOWER CASE
SELECT UCASE("high") FROM DUAL;		-- HIGH
SELECT LCASE("HIGH") FROM DUAL;		-- high

-- REVERSE -> REVERSE THE STRING
SELECT REVERSE("HELLO") FROM DUAL;	-- OLLEH

-- ------------------------------------------------------------------------
SELECT DATEDIFF("2024-11-25","2024-11-15");		-- 10
SELECT DATE_ADD("2024-11-15", INTERVAL 10 DAY);		-- "2024-11-25"
SELECT DATE_SUB("2024-11-25", INTERVAL 10 DAY);		-- "2024-11-15"
SELECT DATE_FORMAT("2024-11-02","%D");			-- 2
SELECT DATE_FORMAT("2024-11-02","%M");			-- 11
SELECT DATE_FORMAT("2024-11-02","%Y");			-- 2024
SELECT DAYNAME("2024-11-04");				-- MONDAY
SELECT DAYOFYEAR("2024-11-04");				-- 309
SELECT EXTRACT(DAY FROM "2024-11-04");			-- 4
SELECT EXTRACT(MONTH FROM "2024-11-04");		-- 11
SELECT EXTRACT(YEAR FROM "2024-11-04");			-- 2024
SELECT WEEKOFYEAR("2024-11-04");			-- 45

-- PERIOD_DIFF ONLY CONTAIN YR & MNTH
SELECT PERIOD_DIFF(201710,201705);			-- 5

SELECT IFNULL(NULL,"HELLO");				-- HELLO
SELECT IFNULL("SQL CLASS","HELLO");			-- SQL CLASS
SELECT ISNULL(NULL);					-- 1
SELECT ISNULL(12);					-- 0

-- ------------------------------------------------------------------------

















